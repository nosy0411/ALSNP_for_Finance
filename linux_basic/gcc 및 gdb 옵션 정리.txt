gcc 및 gdb 옵션 정리

<gcc 컴파일>
1) gcc 파일명(*.c) : Default로 out 파일이 생성된다. (ex a.out)

2) gcc -c 파일명(*.c) : 오브젝트 파일을 생성한다.

3) gcc -c 오브젝트_파일명(*.o) 파일명(*.c)

   gcc -o 실행파일명(*.out) 오브젝트_파일명(*.o)

4) gcc -o 실행파일 파일명(*.c) : 실행 파일을 만든다. (3번을 한줄로...)

[gcc 옵션]

1. -Wall 옵션 : 모든 모호한 코딩에 대해서 경고를 보내는 옵션

2. -W 옵션 : 합법적이지만 모호한 코딩에 대해서 경고를 보내는 옵션

3. -W -Wall 옵션 : 아주 사소한 모호성에 대해서도 경고가 발생

4. O2 옵션 : 최적화 레벨 2로 설정. (대부분의 최적화를 시도)

5. -E 옵션 : 전처리 과정의 결과를 화면에 보이는 옵션 

             (전처리과정 중 발생한 오류를 검증)

	     ※ enhanced Tip: --save-temps 옵션 

6. -S 옵션 : cc1으로 전처리된 파일을 어셈블리 파일로 

             컴파일까지만 수행하고 멈춘다. (*.s)

7. -c 옵션 : as에 의한 어셈블까지만 수행하고 링크는 수행하지 않는다. 오브젝트 파일을 생성한다.

8. -v 옵션 : gcc가 컴파일을 어떤 식으로 수행하는지를 화면에 출력한다.

9. --save-temps 옵션 : 컴파일 과정에서 생성되는 중간 파일인 

                       전처리 파일(*.i)과 어셈블리 파일(*.s)을 지우지 않고,

                       현재 디렉토리에 저장한다. (오류 분석에 사용)

-E = 전처리를 실행하고 컴파일을 중단하게 한다.

-c = 소스 파일을 컴파일 하고 링크를 수행하지 않으며 오브젝트 파일을 생성한다.

-o = 바이너리 형식의 출력파일 이름 지정 default a.out

-I  = 헤더파일을 검색하는 디렉토리 목록을 추가한다.

-L = 라이브러리 파일을 검색하는 디렉토리 목록을 추가한다.

-l  = 라이브러리 파일을 파일을 컴파일시 링크한다.

-g = 바이너리 파일에 표준 디버깅 정보를 표시한다.

-ggdb = 바이너리 파일에 GNU 디버거인 gdb 만이 이해할 수 있는 많은 디버깅 정보를 포함한다.

-O = 컴파일 코드를 최적화 시킨다.

-ON = 최적한 N 단계를 지정한다.

-static = 정적 라이브러리에 링크한다.

-ansi = 표준과 충돌하는 GNU 확장안을 취소

-MM = make 호환의 의존성 목록을 출력한다.

-V = 컴파일 각 단계에서 사용되는 명령을 보여준다.

--------------------------------------------------------------------------------------------
gcc 컴파일 과정

) 전처리 단계 

   소스파일=file.c -> (전처리=cpp) -> 전처리된 파일=file.i

   전처리기(cpp) =  gcc 의 가장 먼저 작동됨, cpp는 소스 파일의 #include #define으로 시작되는 전처리기 부분을 처리

   필요한 헤더파일을 삽입하고 실행 문장의 매크로를 상수로 변환 file.i를 임시 파일을 생성함

2) 컴파일 단계

  전처리된 파일=file.i -> (컴파일=cc1)  -> 어셈블리어 파일=file.s

  컴파일(cc1) =  컴파일러가 전처리된 파일(file.i)로 부터 어셈블리어로 된 파일(file.s)을 생성, 이것 역시 임시적으로 만들어짐

3) 어셈블 단계

  어셈블리어 파일=file.s -> (어셈블=as) -> 오브젝트 파일=file.o

  어셈블(as) = 어셈블리어 된 파일 (file.s)을 기계어로 된 파일(file.o)로 변환

4) 링크 단계

  오브젝트 파일=file.o -> (링크=ld) -> 실행파일=a.out

  링크(ld) = 오브젝트 파일은 printf,scanf 와 같은 라이브러리 함수에 해당하는 코득가 없기 때문에 실행될 수 없다. 또한 여려 파일로 이 

  루어진 프로그램의 경우에도 파일간에 연결이 지지 않아 실행될 수 없는데 라이브러리 함수와 오브젝트 파일들을 연결해 실행 파일을 생

  성하는 단계
-----------------------------------------------------------------------------------------------
[ 전처리기(cpp0) 옵션] : : 소스내에서 사용된 헤더 파일과 define 매크로와 관련된 옵션들이다.

  전처리 과정에서 오류가 발생한다면 cpp0 옵션들을 점검해야 한다.


-l[패스] : 헤더 파일을 탐색할 디렉토리 지정 (ex_: -l/opt/include)

-include[헤더 파일 패스] : 해당 헤더 파일을 모든 소스 내 추가 (ex_: -include /root/my.h)

-D[매크로] : 외부에서 #define 지정 (ex_: -DDEBUF)

-D[매크로]=[매크로 값] : 외부에서 해당 매크로를 정의하고 값을 지정 (ex_: -DDEBUG=1)

-U[매크로] : 외부에서 #endef 지정 (ex_ -UDEBUG)

-M 또는 -MM : make 기술 파일을 위한 소스 파일의 종속 항목 출력

-nostdinc : 표준 C 헤더 파일을 include하지 않음

-C : 전처리 과정에서 주석을 제거하지 않음

-Wp,[옵션 리스트] : 옵션 리스트를 전처리기에 바로 전달


[ C컴파일러(cc1) 옵션] : "C언어 옵션, 경고 옵션, 최적화 옵션, 디버깅 옵션"의 4가지 종류

  "경고 수위 조절 or 최적화 수위 조절"을 하고 싶을 때 사용한다.

<C 언어 옵션>  : C언어 종류와 표준에 관련된 옵션

-ansi : ANSI C 문법으로 문법 검사

-std=[c 표준] : 지정한 C 표준으로 문법 검사 (표준:c89, c99, gnu89, gnu99 등)

-traditional : K&R C문법으로 문법 검사

-fno-asm : asm, inline, typeof 키워드를 사용하지 않음(gnu89 문법 기준)

<경고 옵션> : cc1의 옵션을 조정하여 경고 수위를 조절할 수 있다.

-Wall -W : 모든 경고 메시지 출력(gcc 옵션 참고)

-w : 모든 경고 메시지 제거

-Werror : 모든 경고를 오류로 취급하여 컴파일 중단

-pedantic : C89 표준에서 요구하는 모든 경고 메시지를 표시

-pedantic-errors : C89 표준에서 요구하는 모든 오류 메시지를 표시

-Wtraditional : ANSI C와 K&R C 간에 서로 다른 결과를 가져올 수 있는 부분이 있다면 경고

<최적화 옵션> : (1) 실행 파일의 크기를 줄여 메모리와 하드디스크의 사이즈를 절약 (큰 의미 X)
		(2) 실행 파일의 크기를 줄여 실행 속도를 향상시키는 것.

-O0 : 아무런 최적화를 수행치 않음

-O1 또는 -O : 최적화 레벨 1 수행

-O2 : 최적화 레벨 2 수행

-O3 : 최적화 레벨 3 수행

-O4 : 사이즈 최적화 수행

<디버깅 옵션> : 

-g : 바이너리 파일에 디버깅 정보 삽입

-pg : 프로파일을 위한 코드 삽입

 
[ 어셈블리(as) 옵션] : gcc는 as의 옵션에 대해서는 알지 못한다. -Wa,[as 옵션들] 형식으로 gcc를 거치지 않고 

  바로 전달해야 한다. -Wa, -al, -as와 같은 형식으로 사용하면 as에게 -al -as 옵션이 같이 전해진다.

-Wa,[옵션 리스트] : 어셈블러에게 옵션 리스트를 바로 전달

-Wa,-al : 어셈블된 코드와 인스트럭션을 보임

-Wa,-as : 정의된 심볼을 보임

-l[패스] 옵션 : include 디렉토리를 지정한다. 어셈블리 소스 내에서 사용된 include 지정자가 

                   지정하는 헤더파일을 찾고자 할 때 사용한다.
-W / --no-warn : 경고 메시지를 출력하지 않는다.

-march=[아키텍처 문자열] : 해당 어셈블리


[ 링크(ld) 옵션]

-L[패스] : 라이브러리 탐색 디렉토리 지정 (ex_: -L/opt/lib)

-l[라이브러리 이름] : 해당 라이브러리를 링크 (ex_: -lm)

-shared : 공유 라이브러리와 정적 라이브러리가 같이 있을 경우, 공유 라이브러리를 우선하여

          링크한다. (아무 옵션을 주지 않아도 공유 라이브러리를 우선으로 링크한다.)

-static : 정적 라이브러리와 공유 라이브러리가 같이 있다면, 정적 라이브러리를 우선하여

          링크한다. (속도는 빠르지만 파일 사이즈가 커진다는 점 고려할 것!)

-nostdlib : 표준 C 라이브러리를 사용하지 않음 (OS, 부트로더와 같은 프로그램을 컴파일 할 때 사용)

-nostartfiles : crt1.o 등과 같은 start up 파일을 링크하지 않는다.(OS, 부트로더와 같은 프로그램을 컴파일 할 때 사용)

-Wl,[옵션 리스트] : gcc를 거치지 않고 바로 링크에게 옵션을 정해주고자 할 때 사용한다. (사용법은 -Wa와 동일한다.)

---------------------------------------------------------------------------------------------------------


GDB 옵션 정리


- C/C++ 디버거
- 프로그램 시작, 멈춤 및 수행 도중 조작 가능
- 변수 값 변경 및 추적
- 함수 스택 관리
- 코드 분석
- 프로그램 수행 과정 추적
- 프로그램의 실행 속도가 저해될 수 있음

실행 방법

-g 옵션

- 디버거 툴(gdb)을 사용하기 위한 옵션

- 이버깅 정보를 포함하여 어셈블리 코드 생성

	- 파일 이름
	- 라인 넘버
	- 변수와 함수들의 이름과 타입

- -O 옵션과 함께 사용시 문제 발생 가능

	- 최적화 과정에서 일부 디버깅 정보가 삭제될 수 있음

- 사용법

ex1) gcc -g test.c -o test
 	gdb test


명령어

l (list)

- 현재 실행중인 라인을 포함하여 소스 코드 10줄 출력

	- 현재 실행중인 라인을 기준으로 중앙에 표시

	- l (list) -

		이전 10줄의 코드 출력

- l (list) [line number]

	- line number에 해당하는 소스 코드의 줄을 기준으로 10줄 출력

- l (list) [function name]

	- 해당 함수를 찾아 함수의 시작 지점을 기준으로 10줄 출력

- set listsize [number]

	- 출력되는 소스 코드의 행 수를 number로 변경

r (run)

- gdb는 바이너리 파일을 로드하지만 실행시키지는 않음.

- 프로그램을 실행하는 명령어

	- r ([arg1][arg2] …)

b (break)

- 프로그램의 실행 중단 지점 설정

	- 현재 실행 중인 라인에 중단 지점 설정

- 줄 번호, 함수 등 중단 지점을 자유롭게 설정 가능

- gdb에서 프로그램 실행 중 중단 지점을 만나면 프로그램 실행을 중지




- b (break) [line number]

	- 현재 소스의 특정 라인에 중단지점 설정

- b (break) [function name]

	- 현재 소스이 특정 함수에 중단지점 설정

- b (break) [line or func] if [condition]

	- 조건부 중단지점 설정

	- 특정 라인 혹은 함수에서 condition을 만족하면 프로그램 실행 중지

- clear / delete 명령어로 중단지점 삭제 가능


info b (break)

- breakpoint 의 목록 확인


d [num]

- 해당 num의 breakpoint 를 삭제하는 명령어

c (continue)

- 중단된 현재 프로그램의 실행을 계속 진행

	- 프로그램 실행 도중 중단 지점에 도달하면 프로그램 실행 중지

	- 프로그램 실행 도중 종료되면 프로그램 종료

- 중단지점 설정 후 중단지점에 도달하기 위해 주로 사용

n (next)

- 프로그램의 다음 행을 실행하는 명령어

	- 단 하나의 행을 실행한 후 프로그램 실행을 중지

- 버그가 있는 부분을 찾아낼 때 유용하게 사용

	- next 를 통해 프로그램을 줄 단위로 실행

- 현재 정지되어 있는 줄을 실행한 후 다음 줄 실행 이전에 정지

- 함수 내부로 진입하지 않고 함수를 실행

	- 함수 내부에 버그가 있는 경우 확인 불가능

	- 함수 내부에 무한 루프가 실행되는 경우 gdb로 돌아오지 않음

	- s (step) 명령어를 통해 해결 가능




- n (next) [line number]

	- [line number] 만큼의 줄을 한 번에 실행

p (print) [expression]

- expression의 결과를 출력

- expression은 다음과 같을 수 있음

	- 단일 변수

		-> 단일 변수의 값 출력

	- 변수를 포함한 수식

		-> 해당 수식의 계산 결과 출력

	- 함수

		-> 호출된 함수가 반환하는 값 출력

- #define으로 선언된 매크로는 확인 불가능



where

- 현재 실행중인 프로그램에서 함수의 호출상태를 볼 수 있음

- main 함수부터 시작해서 호출된 함수를 보여주며, 이 목록을 call stack 이라 함



up <num>

- call stack 에서 상위 함수의 위치로 이동

- num에 써진 숫자만큼 상위로 이동하고, num이 없으면 1만큼 이동

- 상위 함수로 이동하면 프로그램 내 현재 위치가 상위 함수에 있는 것처럼 변수 등을 출력할 수 있음



down <num>

- call stack 에서 하위 함수의 위치로 이동

- up과 반대로 이동을 하고 그 외 특성은 같음



frame <num>

- stack frame의 정보를 출력하는 명령어

- where 명령어로 출력된 call stack 의 맨 앞에 있는 숫자를 num으로 주면, 그에 맞는 frame의 정보를 출력

- num을 주지 않으면 현재 선택되어 있는 frame의 정보를 출력

- 처음 frame 명령어 실행 시 0번

- 함수 이름, 아규먼트, 파일명, 행 번호 등을 출력



select-frame <num>

- frame을 선택하는 명령어

- 단독으로 쓰이지 않고, frame 관련 명령어에서 frame 번호를 지정해줄 때 사용



info frame <num>

- 현재 선택되어 있는 frame의 자세한 정보를 보여줌

- 함수 이름, 아규먼트, 파일명, 행 번호 외에 레지스터의 값들을 보여줌

- num을 주지 않으면 select-frame으로 선택된 frame의 정보를 보여줌

-----------------------------------------------------------------------------------------------


<프로파일링>

